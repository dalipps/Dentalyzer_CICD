import { MathUtils, Vector3 } from 'three'
import { calculateDirection, getHalfCutting, getIntersectionBetweenMarks } from '../calculation'
import { calculateAngle } from '../calculation/angle-calculation.utils'
import { FrsEdge } from '../edge'
import { FrsMark, FrsMarkPositionMap, getVectorFromPosition } from '../mark'
import {
	FrsBisectorGeneration,
	FrsEdgeIntersectionGeneration,
	FrsGenerationDataType,
	FrsHalfCuttingGeneration,
	FrsMarkIntersectionGeneration,
} from './frs-generation-data.model'

export const HELPER_SCALAR = 37

// TODO: hover over Generated marks
export function checkAutoGeneratedMarks(
	allMarks: FrsMark[],
	allEdges: FrsEdge[],
	setMark: FrsMark
): FrsMarkPositionMap[] {
	const generatedMarks: FrsMarkPositionMap[] = []

	allMarks
		.filter((m) => m.generationData)
		.forEach((mark) => {
			let newValue: Vector3 | undefined
			switch (mark.generationData?.id) {
				case FrsGenerationDataType.EdgeIntersection:
					newValue = checkEdgeIntersection(
						mark.generationData,
						setMark,
						allMarks,
						allEdges,
						getVectorFromPosition(mark.position)
					)
					break
				case FrsGenerationDataType.HalfCutting:
					newValue = checkHalfCutting(mark.generationData, setMark, allMarks, getVectorFromPosition(mark.position))
					break
				case FrsGenerationDataType.MarkIntersection:
					newValue = checkMarkIntersection(mark.generationData, allMarks, setMark, getVectorFromPosition(mark.position))
					break
				case FrsGenerationDataType.Bisector:
					newValue = checkBisector(mark.generationData, allMarks, setMark, getVectorFromPosition(mark.position))
					break
			}

			// TODO: david check isSelected, kann das noch an anderen Stellen verwendet werden und muss im Store updated werden: Für setPositonsOnMark showLabel? show label überpüfen visiblity
			if (mark.position !== newValue)
				generatedMarks.push({ markId: mark.id, position: newValue, showLabel: mark.isSelected })
		})

	return generatedMarks
}

function checkEdgeIntersection(
	data: FrsEdgeIntersectionGeneration,
	setMark: FrsMark,
	allMarks: FrsMark[],
	allEdges: FrsEdge[],
	initialValue?: Vector3
): Vector3 | undefined {
	const edge1 = allEdges.find((e) => e.id === data.edge1)
	const edge2 = allEdges.find((e) => e.id === data.edge2)

	if (edge1 && edge2 && (setMark.edgeTypes.includes(data.edge1) || setMark.edgeTypes.includes(data.edge2))) {
		const edge1mark1 = allMarks.find((m) => m.id == edge1.markType1)
		const edge1mark2 = allMarks.find((m) => m.id == edge1.markType2)
		const edge2mark1 = allMarks.find((m) => m.id == edge2.markType1)
		const edge2mark2 = allMarks.find((m) => m.id == edge2.markType2)

		if (!edge1mark1?.position || !edge1mark2?.position || !edge2mark1?.position || !edge2mark2?.position) {
			return
		}

		return getIntersectionBetweenMarks(edge1mark1, edge1mark2, edge2mark1, edge2mark2)
	}

	return initialValue
}

function checkHalfCutting(
	data: FrsHalfCuttingGeneration,
	setMark: FrsMark,
	allMarks: FrsMark[],
	initialValue?: Vector3
): Vector3 | undefined {
	const mark1 = allMarks.find((m) => m.id === data.point1)
	const mark2 = allMarks.find((m) => m.id === data.point2)

	if (mark1 && mark2 && (setMark.id === data.point1 || setMark.id === data.point2)) {
		return getHalfCutting(mark1, mark2)
	}

	return initialValue
}

function checkMarkIntersection(
	data: FrsMarkIntersectionGeneration,
	allMarks: FrsMark[],
	setMark: FrsMark,
	initialValue?: Vector3
): Vector3 | undefined {
	if ([data.line1point1, data.line1point2, data.line2point1, data.line2point2].includes(setMark.id)) {
		const edge1mark1 = allMarks.find((m) => m.id == data.line1point1)
		const edge1mark2 = allMarks.find((m) => m.id == data.line1point2)
		const edge2mark1 = allMarks.find((m) => m.id == data.line2point1)
		const edge2mark2 = allMarks.find((m) => m.id == data.line2point2)

		if (!edge1mark1?.position || !edge1mark2?.position || !edge2mark1?.position || !edge2mark2?.position) {
			return
		}

		return getIntersectionBetweenMarks(edge1mark1, edge1mark2, edge2mark1, edge2mark2)
	}

	return initialValue
}

function checkBisector(
	data: FrsBisectorGeneration,
	allMarks: FrsMark[],
	setMark: FrsMark,
	initialValue?: Vector3
): Vector3 | undefined {
	if ([data.line1point1, data.line1point2, data.line2point1, data.line2point2].includes(setMark.id)) {
		const edge1mark1 = allMarks.find((m) => m.id == data.line1point1)
		const edge1mark2 = allMarks.find((m) => m.id == data.line1point2)
		const edge2mark1 = allMarks.find((m) => m.id == data.line2point1)
		const edge2mark2 = allMarks.find((m) => m.id == data.line2point2)

		if (!edge1mark1?.position || !edge1mark2?.position || !edge2mark1?.position || !edge2mark2?.position) {
			return
		}

		const point1 = getVectorFromPosition(edge1mark1.position)
		const point2 = getVectorFromPosition(edge2mark1.position)
		const intersection = getIntersectionBetweenMarks(edge1mark1, edge1mark2, edge2mark1, edge2mark2)

		if (!point1 || !point2 || !intersection) {
			return
		}

		const direction1 = calculateDirection(point1, intersection)?.normalize()
		const direction2 = calculateDirection(intersection, point2)?.normalize()
		const angle = calculateAngle(direction1, direction2)

		if (angle) {
			const bisector = angle / 2
			const radians = MathUtils.degToRad(bisector)
			const bisectorDirection = new Vector3(Math.cos(radians), Math.sin(radians), 0)
			const intersectionVector = getVectorFromPosition(intersection)

			if (intersectionVector) {
				return intersectionVector.add(bisectorDirection).addScalar(HELPER_SCALAR)
			}
		}
	}

	return initialValue
}
